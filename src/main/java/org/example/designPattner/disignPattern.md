### 中介者模式（moditor）同级别的对象直接互相交互 抽离moditor 每个obj 的 action just use moditor achieve

### 访问者模式（visitor pattern） 有一组对象，包含许多属性，每个访问者只访问特定的部分属性，相同的方法，不一样的访问者，效果不一样

### 门面模式（face pattern） 提供一个对象，统一对外暴露，忽略内部具体的实现

### 适配器模式（adapter） 通过适配器 将源对象（source） -> 目标对象（target）
  1 类适配器 ：继承 source 对功能进行适配
  2 接口适配器：实现 interface 对功能进行适配
  3 对象适配器：借助组合的方式，将一个对象转换成另外一个对象

### 装饰器模式（decotor）：不改变对象行为的情况下，对对象功能进行增强（减弱）；装饰者和被装饰者必须是同宗（装饰者持有被装饰者对象）

### 代理模式（proxy） 代理类持有被代理对象，通过代理类提供的方法调用被代理对象功能

### 策略模式（strategy）:将行为封装为策略，在使用时候不通策略，执行不同行为

### 桥梁模式（bridge）：将抽象与接口分开，使用时按需传入，传入不一样的实现，达到不通的效果（不破坏封装的情况下，抽象和实现都可以独立扩展）

### 责任链模式（chain）：通过责任链，串联各对象，使得链上的每个对象都有机会处理请求；

### 模版模式（templete）；提供模版供子类实现，代码复用，封装不变，扩展可变

### 命令行模式（commend）：调用者 Invoker and receiver 解耦合 ；invoker 通过cmd 调用receive执行一系列action

### 观察者模式（notify）：被观察者状态发生变化，通知观察者做对应处理

### 状态模式（state）：不同状态对应不同的处理行为，提供一个上下文，维护所有状态，当前状态之下结束，通过上下文触发下一个状态执行

### 迭代器模式（itterable）：提供一个迭代器，来支持对集合数据的操作

### 解析器模式（expression）：

### 原型模式（prototype）：提供一个对象，实现cloneable 接口，每次调用clone方法进行复制（属性时引用类型时copy的时地址，需要注意）

### 享元模式（flyweight）：使用共享对象，支持大量细粒度的对象，类似于池


